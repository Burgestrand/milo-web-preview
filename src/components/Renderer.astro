---
---

<canvas></canvas>

<style>
	canvas {
		width: 500px;
		height: 500px;
		border: 4px solid orange;
		outline: 4px solid grey;
	}
</style>

<script>
	import * as THREE from 'three'
	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js'
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
	import * as materials from '@config/filaments'
	import printables from '@config/printables'
	import { colors as colorStore } from '@stores/settings.ts'
	import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'

	const main = document.querySelector("main")
	const canvas = main.querySelector("canvas")
	const width = main.scrollWidth - 20
	const height = main.scrollHeight - 20
	const ratio = width / height
	const camera = new THREE.PerspectiveCamera(75, ratio, 0.10, 10);

	const scene = new THREE.Scene()

	const renderer = new THREE.WebGLRenderer({
		canvas,
		antialias: true
	})
	renderer.setPixelRatio(window.devicePixelRatio)
	renderer.setSize(width, height)
	renderer.toneMapping = THREE.ACESFilmicToneMapping
	renderer.toneMappingExposure = 1
	renderer.physicallyCorrectLights = true

	const controls = new OrbitControls(camera, renderer.domElement)
	controls.addEventListener('change', render)
	controls.target.set(0, 0, 0)

	// Add light to scene
	const light = new THREE.DirectionalLight(0xffffff, 3)
	light.position.set(1, 1, 1).normalize()

	camera.position.z = 0.8
	camera.position.y = 0.4
	camera.position.x = 0.5
	camera.lookAt(0, 0, 0)

	const environment = new RoomEnvironment(renderer)
	const pmremGenerator = new THREE.PMREMGenerator(renderer)

	scene.background = new THREE.Color(0xbbbbbb);
	scene.environment = pmremGenerator.fromScene(environment).texture;

	const loader = new GLTFLoader()
	loader.load("/milo.glb", async function(gltf) {
		console.group("Milo.glb")
		console.debug({ gltf })

		const printablesByName = new Map(printables.map(printable => [printable.name, printable]))
		const nodesByPrintable = new Map(printables.map(printable => [printable, []]))

		const model = gltf.scene

		// Find all nodes for each printable.
		model.traverse((node) => {
			const printable = printablesByName.get(node.name)
			if (printable === undefined) {
				return
			}

			nodesByPrintable.get(printable).push(node)
		})

		// Double-check 1-to-1 mapping of printables to nodes.
		nodesByPrintable.forEach((nodes, printable) => {
			if (nodes.length === 0) {
				console.warn(`No nodes found for ${printable.name}`)
			} else if (nodes.length > 1) {
				console.warn(`Multiple nodes found for ${printable.name}`)
			}
		})

		const nodesByColor = [...nodesByPrintable.entries()].reduce((map, [printable, newNodes]) => {
			const color = printable.color
			const nodes = map.get(color) || []
			map.set(color, nodes.concat(newNodes))
			return map
		}, new Map())

		colorStore.subscribe((colorToFilament) => {
			nodesByColor.forEach((nodes, color) => {
				const filament = colorToFilament[color]

				nodes.forEach((node) => {
					node.children.forEach((child) => {
						if (child.isMesh) {
							child.material = filament.material
						}
					})
				})
			})
		})

		await renderer.compileAsync(model, camera, scene)

		scene.add(model)
		console.groupEnd()
	}, undefined, function(error) {
		console.error(error)
	})

	function render() {
		renderer.render(scene, camera);
	}

	function animate() {
		requestAnimationFrame(animate);
		render()
	}

	animate()

</script>